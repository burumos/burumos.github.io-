# shell script
## 雑多memo
- 実行権限を付ける `chmod +x file-name`
- シェルスクリプトを実行するには実行権限と読み取り権限が必要
- シェルスクリプトの先頭にある`#!/bin/bash`はshebang(シバン)
- コマンドラインの途中で改行を入れる場合は行末に`\`を入れる
- 1つの行に複数のコマンドを書きたい場合はコマンドを`;`で区切る
- bashのコマンド優先順位
  1. エイリアス
  2. 予約語
  3. 関数
  4. 組込みコマンド
  5. 実行可能ファイル(ls, ps...)
- コマンド検索パス シェルが実行ファイルを探すディレクトリのパス
  - PATH変数に`:`区切りで複数のディレクトが設定できる
  - `PATH=$PATH:$HOME/bin` コマンドパスの追加

------------
------------

## 変数

### 変数宣言`my_dir=/home/taro`
- `=`の左右にスペースやタブを入れてはダメ
- 変数の値は文字列として扱われる
- `empty=`だと空文字が代入される

### 変数参照`$my_dir` or `${my_dir}`
- `$`を付ける

### 環境変数
- 現在のシェルからコマンドへ引き継がれる変数
- 宣言`export VARIABLE_NAME=VALUE`
- 実行コマンド名に書くと1回限りの環境変数を定義できる
  `VARIABLE_NAME=value ./script.sh`
- 特殊なシェル変数
  - `HOME` ログインしているユーザのホームディレクトリのフルパス
  - `PWD` カレントディレクトリ
  - `OLDPWD` cdで移動する前のディレクトリ
  - `SHELL` ログインシェルのフルパス
  - `BASH` 現在動作しているbashコマンドのフルパス
  - `BASH_VERSION` bashのバージョン
  - `LINENO` 現在実行しているシェルスクリプトの行番号
  - `LANG` 現在の地域や言語
  - `PATH` シェルがコマンドを探すディレクトリ。`:`区切りで指定
  - `IFS` シェルの区切り文字を指定(`echo "$IFS"| od -a`)

### 位置パラメータ(`$1, $2, $3 ...`) コマンドの引数
- `$*` => `"$1 $2 ... $N"`
- `$@` => `"$1" "$2" ... "$N"`
- `$#` 引数の数

### プロセスの変数
- `$?` 最後に実行したコマンドの結果。0で成功。0以外で失敗。
- `$$` 実行しているシェルのプロセスID(プロセス間で異なるファイルを
    書きこみたいなどのときに使われる)
- `$!` バックグラウンド実行したコマンドのプロセスID

### declare 変数宣言
- `declare -r name=value` (読み取り専用 readonlyも同様)
- `declare -i num` (整数型)
  - `declare -i result=x+y` $がいらない
  - 整数型変数に代入を行なうたびに右辺が計算される
  - 使える演算子`**(べき乗),*,/,%,+,-`

### `declare -a array` 配列(明示的な宣言)
- `${array[0]}`要素の参照
- `${#array[@]}` 要素数の取得
- `array[1]=value` 要素への代入
- `unset array[1]` 要素の削除
- `${array[*]}  ${array[@]}` すべての要素の参照
- `ary2=("${ary1[@]}")` 配列のコピー
- `ary2=(aaa bbb "${ary1[@]")` or `ary+=(value)` 要素の追加
- `${!ary[*]}` or `${!ary[@]}` 配列内で値が存在するインデックス
    一覧の取得

### 連想配列
- `declare -A user=([id]=5 [name]=taro)` declare -aが必須。v4以降
- 要素の参照、削除、代入などのやり方は配列と同じ

------------
------------



## 展開とクォーティング
### パス展開
- パス名展開に使えるワイルドカード
  - `?` 任意の1文字
  - `*` 任意の文字列
  - `[]` []内に含まれる、いずれか1文字
  - `[!]`or`[^]` []内に含まれない、いずれか1文字
- `ls string.?` string.の後に何か1文字続くファイルまたはディレクトリ
- `ls file[1-3].txt` file1.txt or file2.txt or file3.txt
- 結果にマッチするファイルがなければ記号がそのままコマンドに渡される
- `*,?,[]`は隠しファイルの先頭.にマッチしない

### ブレース展開
- `echo f-{01,02}.txt` f-01.txtとf-02.txtに展開
- `echo f-{3..9}` f-3,f-4,f-5,...f-9に展開
- `echo f-{3..9..2}` f-3,f-5,f-7,f-9

### チルダ展開
- `~` ユーザのホームディレクトリを指定

### パラメータ展開
- `ls $HOME` or `ls ${HOME}`変数を展開
- `${name:-taro}`nameに値が設定されていなければtaroを展開。デフォ
    ルト値みたい
- `${name:=taro}` nameに値が設定されていなければ展開と代入
- `cd ${my_dir:?Do set my_dir}` エラー制御
- `${name:+taro}` :-とは逆に値が設定されていればtaroを展開
- `${name:4}` 4文字目以降を展開。負の数は末尾から削除
- `${name:2:4}` 2文字目から4文字を展開
- `${arr[@]:1}` 配列の2番目から取得
- `${#name}` 文字数を展開
- `${name#ab}` パターンにマッチした部分を取り除いた値に展開
    (#は最短一致、##は最長一致)マッチしない場合はそのまま値を展開
- `${name%fg}` 後方最短一致
- `${arr[@]%%.*}` 配列に対して行なうと各要素に対して展開
- `${name/./_}` 置換してから展開。パターンの前に#や%で前方、後方を指定
- `${name//./_}` すべてを置換してから展開

### コマンド展開
- `echo $(date +%Y-%m-%d)` `$()`で実行結果を文字列で展開。*``*でも同様

### 算術式評価
- 整数型の変数への代入分の右辺に書く計算式の規則を算術式評価
- `(())`の中や`let 式`でも使える(letでは<<などがそのまま使えないので
  \`で囲む)
- `((num = 10 * 2))`
- `(())`の計算結果(真偽値)は`$?`で参照できる(falseが1)

### 算術式展開
- `echo $((5 + 7))` 算術式評価によって評価した値を展開

### プロセス展開
- `ls . > tem.txt` コマンドの実行結果をtem.txtに展開
- `diff <(ls .) <(ls ../x)` 一時ファイルを作らず実行結果を使う

### 履歴展開
- 履歴展開の記号
  - `!` 履歴置換開始
  - `!n` n個目のコマンドラインを参照
  - `!-n` 現在からn個前
  - `!!` 直前
  - `!string` stringで始まる最後のコマンド
  - `!?string` stringを含む最後のコマンド
  - `^string1^string2^` string1をstring2で置換して最後のコマンドを繰り
      返す
  - `!#` これまでに打ち込んだコマンドライン全体
- シェルスクリプトでは使わないので意図せず展開されないようにクォーティ
  ングしよう

### クォーティング
- 記号を文字そのものとして使いたいときの記法
- `\`, `''`, `""`でクォーティング
- `''`で囲んだ場合はすべての特殊記号の意味が失なわれる
- `""`は`$'\`の意味が残る。パラメータ展開などが行なえる
  - `echo "home dir: $HOME"` <= 展開される

## 制御構造
### if
```SHELL
if 条件; then
    # 処理
elif 条件2; then
    # 処理2
else
    # 処理3
fi
```
#### 条件式
- 0の場合は成功、0以外の場合は失敗
- `[]` testコマンド
  - 真の場合は0を,偽の場合は1を返す
  - `[`の後`]`の前にスペースが必要
  - 条件部の後ろは`;`で区切る(改行でも可)
  - `<.>,(,))`なでの記号はクォートが必要
    - `if [ "$str1" < "$srt2" ]; then` は<でエラー
    - `if ( "$str1" = "$srt2" ) ]; then` は()でエラー
- `[[]]` testコマンド `[]`との違い
  - `-a`や`-o`の代りに`&&`や`||`が使える
  - `<.>,(,))`なでの記号はクォートが不要
  - 単語分割とパス名展開が行なわれない
  - 否定は`! [[ 条件 ]]`
- 処理は空にできない。したければ`:`を使え
- 単語分割
  - `[]`内だと変数を展開したときにスペースが含まれるとそれを区切りに別
      の値と解釈して実行しようとする.  
      => 防ぐには`""`で囲むか`[[]]`を使う必要がる
- パターンマッチ
  - `[[]]`内で`==,!=`を使うと右辺をパターン文字列と見做される
    - `[[ $str == x* ]]` パターンマッチ
    - `[[ $str == $pattern ]]` 変数の値でパターンマッチ
  - 防ぐには`""`で囲む必要あり
  - `=~`演算子を使うと正規表現でパターンマッチを行なう
- 文字列の比較
  - `str1 = str2` 等しい(`==`と同じ)
  - `str1 != str2` 等しくない
  - `-n str1` 空文字列ではない
  - `-z str1` 空文字列である
  - `str1 < str2` 辞書的に前
  - `str1 > str2` 辞書的に後ろ
- 整数の比較
  - `int1 -eq int2` 等しい
  - `int1 -ne int2` 等しくない
  - `int1 -lt int2` 小さい <
  - `int1 -le int2` 以下 <=
  - `int1 -gt int2` 大きい >
  - `int1 -ge int2` 以上 >=
- ファイル属性
  - `-a file` ファイルが存在(`-e`と同じ)
  - `-d file` ディレクトリである
  - `-f file` 通常ファイルである
  - `-h file` シンボリックリンクである(-Lと同じ)
  - `-r file` 読み取りパーミッションが与えられている
  - `-s file` ファイルサイズが0より大きい
  - `-w file` 書き込みパーミッションが与えられている
  - `-x file` 実行パーミッションが与えらている
  - `-G file` ファイルのグループが現在実行中のシェルのグループに所属し
      ている
  - `-N file` 変更時刻が読み込み時刻以降である
  - `-O file` ファイルのオーナーが現在実行中のシェルのユーザである
  - `-S file` ソケットである
  - `file1 -nt file2` file1の変更時刻がfile2より新しい
  - `file1 -lot file2` file1の変更時刻がfile2より古い
- 演算子結合
  - `cond1 -a cond2` cond1 and cond2
  - `cond1 -o cond2` cond1 or cond2
  - `!cond`
  - `()` グループ化
- `[ cond1 ] && [ cond2 ]` cond1の結果が0のときにcond2を実行
- `[ cond1 ] || [ cond2 ]` cond1の結果が0以外のときにcond2を実行


### for
構造
```SHELL
for 変数 in 単語リスト
do
    # 処理
done
```

例
```SHELL
for i in a b c
do
    echo $i
done
```

- `for file in *.txt` パス名展開を使って指定
- `for i in "$@"` 引数に対して繰り返し
- `break`でループから脱出
- `continue` で次の繰り返しへ

### case
構造
```SHELL
case 文字列 in
    パターン1)
        #処理
        ;;
    パターン2)
        #処理
        ;;

esac
```
例
```SHELL
case "$file" in
    *.txt)
        head "$file"
        ;;
    *.tar.gz | *.tgz) # or条件
        tar xzf "$file"
        ;;
    *)
        echo "not supported file : $file"
        ;;
esac
```

### while
構造
```SHELL
while コマンド
do
    # 繰り返し
done
```

例
```SHELL
i=0
while [[ $i -lt 10 ]]
do
    echo "$i"
    i=$((i + 3))
done
```
## リダイレクト
- `ls > result.txt` 標準出力先をresult.txtに変更
- `ls eee 2> error.txt` エラー出力をerror.txtに変更
    (2はファイルディスクリプタと呼ばれる)
- `tr b B < book.txt` book.txtを入力元としてリダイレクトしてbをBを置き
    換えて標準出力に出力する
- 標準入出力
  - 標準入力(stdin) 通常はキーボード(0>)
  - 標準出力(stdout) 通常は端末ディスプレイ(1>)
  - 標準エラー出力(stderr) 通常は端末ディスプレイ(2>)
- noclobber リダイレクトによるファイル上書きを防止
  - `set -o noclobber` ファイル上書き禁止(`>|`で強制上書き)
  - `set +o noclobber` 上書き禁止を解除
- `>>` で追記
- 標準出力と標準エラー出力をまとめる
  - `2>&1`でまとめられる
  - `ls dir dir2 > result.txt 2>&1` 2番目のファイルディスクリプタを1番
      目のファイルディスクリプタにまとめた
  - x `ls dir dir2 2>&1 > result.txt` 標準出力であるディスプレイにエラー
      を表示した後、標準出力をresult.txtに出力される
  - `&>`で`2>&1`がなしで標準出力とエラー出力をまとめられる
  - `&>>`で追記
  - `echo 'error message' 1>&2`でエラーを明示して出力
  - `> /dev/null`で出力を捨てる
- 注意点
  - `2 >`の様にファイルディスクリプタ番号の後にスペースを入れない
  - `1> &2` も同様にダメ
  - リダイレクト元とリダイレクト先が一緒だと空になる(入力の前に空にす
      るため)
## ヒアドキュメント
構造
```SHELL
コマンド << 終了文字
    ヒアドキュメント内容
終了文字
```
- 終了文字列は、1つの行に単独で書かないといけない
- ヒアドキュメントの内側では、パラメータ展開、コマンド置換、算術展開が
    行なわれる
-  "\`$" を記号として表示する場合は\でエスケープが必要
- 全体で展開したくない場合は`<<`の後の終了文字列をクォート
- `<<-`で各行頭のtabが無視される

### ヒアストリング
- ヒアドキュメントを1行で書いもの
- パラメータ展開、コマンド置換、算術式展開、プレース展開、チルダ展開が
    行なわれる
- `tr b B <<< $str`

## パイプ
- コマンドの出力内容をリダイレクトしてファイルに出力する代わりに、別の
    コマンドの入力にする
- `コマンド1 | コマンド2`
- `2>&1`で標準エラー出力も渡せる(`|&`で省略可能)

## コマンドのグループ化
- 出力先の記述をまとめる
```SHELL
{
    コマンド1
    コマンド2
    コマンド3
} > ファイル
```
- 1行で書く場合はコマンドの終りに`;`追加する(最後も必要)
  `{ echo "ee"; cat file.txt; ls .;} > result.txt`
- `{`の後のスペースも必須
- `()`で代りに囲むとサブシェルを利用
  - 子プロセスで動作
  - cdなどで環境を変更しても抜けると元に戻る
  - 1行でも書ける

## 関数
### 関数定義
```SHELL
function 関数名()
{
    # 処理
}
```
- `function`または`()`のどちらか一方が省略可能
### 変数
- 変数は指定しない限りシェルスクリプ全体で有効なグルーバル変数
- `local 変数名=値` 関数内で有効なローカル変数を宣言
- 参照先の変数は実行時に決まる
- `local`には`declare`と同じオプションが指定できる

### 位置パラメータ
- 関数を呼び出したときの引数を `$1,...$N`で使える
- `$#`は引数の数
- `$0`はシェルスクリプトの名前
- `${FUNCNAME[0]}`は関数名。`FUNCNAME`には現在呼び出されている関数名が
    すべて格納されている

### 終了ステータス
- `return 数値` 終了ステータスを返す
- `$?l`で終了ステータスを確認
- 正常終了で0,異常終了で0以外を返すのが一般的

## 組込みコマンド
### : ヌルコマンド
- 常に終了ステータスとして0を返す
- trueと同じ機能

無限ループ
```SHELL
while :
do
    # 処理
done
```

### echo
- 引数で指定した文字列を標準出力に出力する
- オプション
  - `-n` 最後に改行しない
  - `-e` 特殊なエスケープ文字が使える(`\t`タブ、`\n`改行など)
  - `-E` エスケープを無効化
- `echo -e '\x2Dn'` オプション"-n"を文字列として出力


### printf
- 書式に基づいて文字列を標準出力
- `printf '%s %d' strings 123`
- 書式
  - `%s` 文字列
  - `%d` 整数値
  - `%x` 16進数値(a~fは小文字)
  - `%X` 16進数値(A~Fは大文字)
  - `%%` %
- `%4x` 4桁表示の16進数
- `%04x` 0埋め4桁表示の16進数
- `-n`のような任意の文字を出力するのに便利
- `-v`オプション 変数に結果を代入
    `printf -v var 'value = 0x%x' 99`

### pwd
- カレントディレクトリを絶対パスデ標準出力に出力
- オプション
  - `-P` シンボリックリンクを物理的なパスに変換
  - `-L` シンボリックリンクがあってもそのまま出力

### cd
- カレントディレクトリを引数で指定したディレクトリに変更
- オプション
  - `-P` シンボリックリンクを物理的なパスに変換して変更
  - `-L` シンボリックリンクがあってもそのままにして変更

### command
- 優先順位が低い組込みコマンドや実行可能ファイルを実行
- `command ps`

### buildin
- 組込みコマンドだけからコマンドを探して実行
- `buildin cd`

### type
- コマンドの種別を表示
- `type la`
- 優先順位の最も高いもどだけ表示される
- 存在しないコマンドの場合はエラーを返すため特定のコマンドが存在してい
  るかどうかを判定するのに使える
- オプション
  - `-a` 複数の種別がある場合すべて表示

### shift
- 位置パラメータの番号をずらす
- 引数の数値だけずれる。デフォルトは1
- `$#`より大きな値を指定した場合は変化しない

### set
- 現在設定されているシェル変数の一覧を表示する
- 位置パラメータの値を設定する。設定すると前の値が全て捨てられる
  - `set var1 var2 var3 ...`
  - オプションと見做される値を設定したい場合は`set -- var1 var2..`
- オブション
  - `-o オブション名` シェルのオプションを有効に設定
  - `+o オブション名` シェルのオプションを無効に設定
  - `-o` オブションの一覧を表示

### unset
- 変数の削除を行なう
- 値を一度も代入していない未定義の状態になる
- オプション
  - `-f` 関数に限定して削除
  - `-v` 変数に限定して削除

### read
- 標準入力から1行分文字列を読み取って、引数で指定した名前の変数に代入
- `read var1 var2 ...`
- 変数を1つしか指定していない場合は行全体がその変数に代入される
- `\`をエスケープ文字として解釈される
- 行の先頭と末尾にあるIFSに含まれる文字を取り除く。
  - `IFS= read -r var` でそれを防げる
- オプション
  - -r `\`をエスケープ文字として解釈しない

### trap
- 現在のプロセスに対して送られたシグナルを捕捉する
- `trap '処理' シグナル1 シグナル2 シグナル3 ...`
- 本来あった動作を上書きし処理を行なう
- `kill -l`でシグナルの一覧を表示
- 次のものはすべて同じシグナルを指す
  - INT, SIGINT, 2
- trapコマンドで扱う主なシグナル
  - `HUP` プロセスの再起動を通知
  - `INT` プロセスに割り込みを通知(C-c)
  - `QUIT` プロセスに終了を通知して、コアダンプファイルを作成する(C-\)
  - `TERM` プロセスに終了を通知する

### wait
- バックグラウンドで動作しているプロセスが終了するまで待つ
- プロセスIDを指定すると指定したプロセスが終了するまで待つ
- %1, %2のようにジョブ番号も指定できる

### exec
- 引数で指定したコマンドを起動する
- `exec コマンド名 引数1 引数2`
- 新しいプロセスが作成されない
- `exec`を呼び出した時点で元のシェルのプロセスは終了する
- 使い道
  - ラッパースクリプト。余分なプロセスを起動しないので効率的
  - リダイレクト先を変更 `exec > file.txt`

### eval
- 引数で指定した文字列をシェルのコマンドラインとして解釈して実行する
- 動的なコマンドの組むのに

### source
- 引数で指定したファイルに書いてあるコマンドをカレントシェルの中で実行

### env
- 環境変数を指定してコマンドを実行する
- `env 環境変数名=値 コマンド 引数...`
- `#!/usr/bin/env bash`というシェバンの書き方はbashの場所に依存しない
    (envがあるとは限りない...)

### stat
- ファイルのステータス、つまり属性や日付などを表示
- オプション
    - `-L` シンボリックリンクの場合、リンク先の情報を表示
    - `-f` ファイルの情報の代わりにファイルシステムの情報を表示
    - `-c 書式` 出力時の書式（下表参照）を指定する
    - `-t` 情報を簡潔な形式で表示する
- 出力書式
    - `%n` ファイル名
    - `%N`	クオートされたファイル名（シンボリックリンクの場合は参照先ファイル名）
    - `%F`ファイルの種類
    - `%A`, `%a` アクセス権（%aは8進数表記）
    - `%C` SELinuxのセキュリティコンテキスト文字列
    - `%U`, `%u` 所有者のユーザー名（%U）とユーザーID（%u）
    - `%G`, `%g` 所有者のグループ名（%G）とグループID（%g）
    - `%s` 合計サイズ（バイト単位）
    - `%B` `%b` ブロックサイズ（%B）とファイルに割り当てられているブロック数（%b）
    - `%o` 最適なI/O転送サイズサイズのヒント
    - `%m` マウントポイント
    - `%t` メジャーデバイス番号（16進数）
    - `%T` マイナーデバイス番号（16進数）
    - `%D`, `%d` デバイス番号（%Dは16進数、%dは10進数）
    - `%f` rawモード（16進数）
    - `%i` iノード番号
    - `%h` ハードリンクの数
    - `%x`, `%X` 最終アクセス日時、%XはEpoch（1970年1月1日0時0分0秒）からの秒数
    - `%z`, `%Z` 最終修正日時（Modify、内容の変更）、%ZはEpochからの秒数を出力
    - `%y`, `%Y` 最終状態変更日時（Change、属性などの変更）、%YはEpochからの秒数を出力
- `stat -c %s` ファイルサイズを出力

## 正規表現
### 基本正規表現と拡張正規表現
- 違い -> 使用できるメタ文字が異なる
- `grep`で拡張正規表現を使用する場合は`-E`

| 基本正規表現 | 拡張正規表現 | 意味                         |
| --------     | --------     | --------                     |
| .            | .            | 任意の1文字                  |
| []           | []           | []内に含まれるいずれか1文字  |
| [^]          | [^]          | []内に含まれない1文字        |
| ^            | ^            | 行頭                         |
| $            | $            | 行末                         |
| *            | *            | 0回以上の繰り返し            |
| なし         | +            | 1回以上の繰り返し            |
| なし         | ?            | 0回または1回の繰り返し       |
| \[m,n\]      | [m,n]        | m回以上n回以下               |
| \[m\]        | [m]          | ちょうどm回                  |
| \[m,\]       | [m,]         | m回以上                      |
| \            | \            | 直後のメタ文字の打ち消し     |
| \(\)         | ()           | グループ化                   |
| なし         | ｜           | 複数の正規表現をOR条件で連結 |

### grep コマンド
- `grep 検索パターン 検索対象`
- オプション
  - `-E` 拡張正規表現を使用
  - `-F` 正規表現を使用しない
  - `-i` 大文字と小文字を区別しない
  - `-e 検索パターン` 検索パターンを指定
  - `-v` 結果を反転
  - `-n` 行番号を出力
  - `-H` マッチしたファイルのファイル名も出力
  - `-h` ファイル名は出力しない
  - `-l` ファイル名だけ出力
  - `-o` パターンマッチした箇所だけ出力
  - `-q` パターンマッチした結果を出力しない

### sed コマンド
- 入力ストリームに対してテキスト変換などの処理を行なって結果を出力する
- `sed [オブション] スクリプト 入力ファイル`
- オプション
  - `-r` 拡張正規表現
  - `-e スクリプト` スクリプトを指定
  - `-i [バックアップファイル]` ファイルを編集して上書き保存する
### スクリプト
- `[アドレス指定]コマンド`
- アドレス指定方法
  - 数字 指定した行番号
  - /正規表現/ マッチした行
  - $ 最終行
- `s/検索パターン/置換文字列/フラグ`
  - `s/:/ /g`

## tips
### 子プロセスが終了したときに他のプロセスを終了させる
```shell
wait $!
ps -p $job1 1>/dev/null
if [[ $? = 0 ]]; then
    echo "kill process"
    kill $job1
fi
```